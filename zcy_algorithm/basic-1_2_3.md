# 1
### 时间复杂度
![](1-1.jpg)
---
### 冒泡排序
![](1-2.jpg)
---
### 选择排序
![](1-3.jpg)
---
### 插入排序
![](1-4.jpg)
---
### 递归复杂度
![](1-5.jpg)
---
### 归并排序
![](1-6.jpg)
---
### 小和问题和逆序对问题
![](1-7.jpg)
---

# 2
### 荷兰国旗问题（快排的基础）
![](2-1.jpg)
---
### 快排
- 时间复杂度O(NlogN)， 额外空间复杂度O(logN)（**需记录哨兵的下标位置**）
- 经典快排
	- 只有小于等于区间和大于区间
	- 有小于区间，等于区间，和大于区间
	- 复杂度受数据状况影响，当原数组有序时，复杂度退化至O(N^2)
- 随机快排
	- 其它和经典快排一样，只是随机选择一个当做哨兵
	![](2-2.jpg)
---
### 堆排序
- 堆结构的heapInsert与heapify
	![](2-3.jpg)
- 如果只是建立堆的过程， 时间复杂度为O(N)
- 优先级队列结构，就是堆结构
---
### 排序稳定性

可以稳定：
- 冒泡
- 插入
- 归并
- 桶排序

不可以稳定：
- 选择
- 快排
- 堆排
---
### 非基于比较的排序
桶排序：具体实现可分为**计数排序**和**基数排序**，时间复杂度O(N)， 额外空间复杂度O(N)
---
### 排序后相邻两数的最大差值

![](2-4.jpg)
---
### 工程中的综合排序

对原始数组可能运用快排堆排等NlogN的算法，但当子数组的长度小于某一个阈值时，就开始运用插入选择等算法（因为其常数项低）

# 3

### 实现栈和堆
- 栈
	- index表示下一个进来的数即将占用的位置下标
	![](3-1.jpg)
- 队列
	- head表示队头（出队的数所在的位置），tail表示下一个进来的数即将占用的位置下标，size表示队列有效长度
	![](3-2.jpg)
---
### 最小栈
见书

### 队列栈互相转换

- 队列转栈
	- 两个队列。一个data队列，所有压栈都入data队列；一个help队列，要出栈时，把前面所有的数入help队列，data队列只留下最后一个返回作为出栈的数，然后data/help指针互换
	![](3-3.jpg)
- 栈转队列
	- 两个栈。一个push栈，所有入队都压push栈；一个pop栈，当要出队时，若pop栈不空，则返回栈顶；若空，则将push栈的所有数倒过来放入pop栈
	![](3-4.jpg)
---
### 猫狗队列
见书

### 转圈打印矩阵
![](3-5.jpg)
---
### 正方形矩阵旋转90度
![](3-6.jpg)
---
### 反转链表和双向链表
![](3-7.jpg)
![](3-8.jpg)
---
### ZigZag打印矩阵
![](3-9.jpg)
---
### 行列都排序的矩阵中找数
时间复杂度为O(N+M)， 额外空间复杂度为O(1)

从左下或者右上开始找，目标数要么大于或者小于等于当前数，保证了每次只可能往一个方向找；若从左上或者从右下，则两个方向都有可能

![](3-10.jpg)
---
### 打印链表相等的部分
两指针，谁小谁移动，相等则打印并一起移动

### 判断链表是否回文

时间复杂度O(N)， 额外空间复杂度O(N)：
- 直接链表反转成一个新链表，然后逐个比较
- 将链表压栈，然后再出栈逐个比较
- 快慢指针，找到中点，只将后半段压栈，再出栈逐个与前半段比较

时间复杂度O(N)， 额外空间复杂度O(1)：
- 先快慢指针找到中点
	![](3-11.jpg)
- 将后半段的链表反转，前半段最后一个节点指向null
- 逐个比较两个链表
- 将后半段再反转，恢复原链表
---

### 链表的荷兰国旗问题
将单向链表按某值划分成左边小、 中间相等、 右边大的形式

时间复杂度O(N)， 额外空间复杂度O(N)：
- 开辟节点类型的数组，按照数组做，排序好后再遍历数组连接链表

时间复杂度O(N)， 额外空间复杂度O(1)：
- 三个链表，一个大，一个等，一个小；遍历链表，将对应的节点加入对应的链表，最后连接三链表（注意链表为空的情况）
---

### 复制含随机节点的链表

见leetcode 138

- 哈希表，额外空间复杂度O(N)
- 在原链表每个节点后加入自己的复制节点；按照相对关系处理好复制节点的随机指针；两链表拆分（额外空间复杂度O(1)）
---
### 两个单链表相交问题
![](3-12.jpg)

包含三个问题：
- 返回一个单链表的环交点，若无则返回Null
	- 哈希表，遍历过就加入，直到有重复，返回
	- 快慢指针，一定会相交，相交后，快节点回到头结点，快慢节点一起移动，最终一定相交于环节点
	![](3-13.jpg)
- 返回两个无环单链表的交点
	- 判断尾节点是否相等
		- 若不相等则一定不相交
		- 若相等，遍历两链表求各自长度，相减，长的链表先走此步数，再一起移动最后相交，返回
- 一个有环单链表和一个无环单链表一定不相交
- 返回两个有环单链表的第一个交点
	- 两链表环交点相等，只有一种情况					
		![](3-14.jpg)
	- 两链表环交点不相等，两种情况				
		![](3-15.jpg)


		